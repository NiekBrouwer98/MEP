---
title: "method_comparison"
author: "Niek Brouwer"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(ggplot2)
library(data.table)
library(parallel)
# library(igraph)
library(here)
library(fst)
library(assertthat)
library(RColorBrewer)
# library(latex2exp)
library(cowplot)
library(ggpubr)
library(gtools)
source(here("UtilityFunctions.R"))
library('glmnet', quiet = T)
library('ROCR', quiet = T)

# set seed
projectSeed <- 89230689
set.seed(projectSeed)

outDir <- here('scratch')
cells <- getCells()
structures <- getStructures()
TMEStructures <- read_fst(here('scratch/TMEStructures.fst'), as.data.table=T)
ptLevelTMEinteractions <- read_fst(here('scratch/ptLeveLTMEInteractions.fst'), as.data.table=T)
NetworkProperties <- readRDS(here('scratch/NetworkProperties.rds'))

```
## Subtype associations
In a first assessement of the different spatial and quantitative features, we are going to quantify the association between the features and cancer subtypes similar to figure 5 from the paper by Danenberg et al.

By clustering samples, we identify patient subtypes with potential associations to clinical features. This enables us to measure the effectiveness of our spatial characterization. For a comparative analysis, we cluster samples on:
1. densities
2. close-far combinations
3. parameters
4. Danenberg features

We take a closer look at the clusters. Which combinations separate different cancer types and can we find further associations between these clusters and clinical features?

```{r}
# Collect structure proportions
TMEStructures <- here('scratch/ptLeveLTMEInteractions.fst')
TMEStructures <- read_fst(TMEStructures, as.data.table = T)
IDs <- getCells()[, .(metabric_id, isDiscovery)]
IDs <- IDs[, .SD[1], by = metabric_id]
TMEStructures <- merge(x = TMEStructures, y = IDs, by = 'metabric_id') 
TMEStructures[, isTestCohort := ifelse(isDiscovery, 'train', 'test')]
setnames(TMEStructures, 
	c('nInteractionsPerStructure', 'TotalInteractions'),
	c('module_count', 'total_communities'))
TMEStructures[, proportion := module_count / total_communities]
TMEStructures[, proportion := gtools::logit(ifelse(proportion == 1, proportion - 1e-6, proportion + 1e-6))]
structures <- getStructures()
predictors <- TMEStructures[, .(metabric_id, TMEStructure, proportion, total_communities, isTestCohort)]
predictors[, weights := sum(unique(total_communities)), by = metabric_id]
predictors[, total_communities := NULL]
predictors <- dcast(predictors, metabric_id + weights + isTestCohort ~ TMEStructure, value.var = 'proportion')
oldNames <- grep('metabric_id|weights|isTestCohort', names(predictors), invert = TRUE, value = TRUE)
newNames <- paste0('TMEStructure', oldNames)
setnames(predictors, oldNames, newNames)

# Collect structure network properties
nwP <- readRDS(here('scratch/NetworkProperties.rds'))
standardiseNwP <- function(name){
	dt <- nwP[[name]]
	setnames(dt, grep('communities_', names(dt), value = TRUE), 'communityID')
	dt[, type := name]
	return(dt)
}
nwP <- rbindlist(lapply(c('stroma', 'tumour'), standardiseNwP))
IDs <- getCells()[, .(ImageNumber, metabric_id)][, .SD[1], by = ImageNumber]
nwP <- merge(x = nwP, y = IDs, by = 'ImageNumber') 
nwP[, assortativity := NULL] #has NAs
measureVars <- grep('ImageNumber|communityID|type|metabric_id', names(nwP), 
	invert = TRUE, value = TRUE)
PtmeasureVars <- paste0(measureVars, 'PtMean')
nwP[, eval(PtmeasureVars) := lapply(.SD, mean), by = .(type, metabric_id), .SDcols = measureVars]
nwP <- nwP[, .SD[1], by = .(type, metabric_id)]
nwP <- nwP[, .SD, .SDcols = c('metabric_id', 'type', PtmeasureVars)]
nwP <- melt(nwP, id.vars = c('metabric_id', 'type'))
nwP[, variable := paste0(variable, '_', type)]
nwP <- dcast(nwP, metabric_id ~ variable)
nwP <- na.omit(nwP)
nwPredictorsTumour <- grep('_tumour', names(nwP), invert = F, value = T)
nwPredictorsTME <- grep('_stroma', names(nwP), invert = F, value = T)
predictors <- merge(x = predictors, y = nwP, by = 'metabric_id') 


# Collect cell type densities per tissue compartment
cells <- cells[(isTumour)]

# Compute proportions: all, tumour, stroma, vascular, interface
mkProportionBy <- function(byvars, dt, suffix){

	countsBy <- byvars
	totalsBy <- setdiff(byvars, 'meta_description')
	outVar <- paste0('proportion_',suffix)

	dt[, counts := .N, by = byvars]
	dt[, totals := .N, by = totalsBy]
	dt[, eval(outVar) := (counts / totals)]
	dt[, eval(c('counts', 'totals')) := NULL]
	return(dt)
}

ptCellVars <- c('metabric_id', 'meta_description') 
mkProportionBy(byvars = ptCellVars,dt = cells, suffix = 'all')

mkProportionBy(
	byvars = c(ptCellVars, 'is_epithelial'),
	dt = cells, suffix = 'isEpi')

cells[, is_vascular := (Parent_vessel != 0)]
mkProportionBy(
	byvars = c(ptCellVars, 'is_epithelial', 'is_vascular'),
	dt = cells, suffix = 'isVesselByEpi')

mkProportionBy(
	byvars = c(ptCellVars, 'is_epithelial', 'is_interface'),
	dt = cells, suffix = 'isInterfaceByEpi')

proportionVars <- grep('proportion_', names(cells), value = T)
phenotypeVars <- grep('meta_|phenotype|colours', names(cells), value = T)
indicatorVars <- grep('^is_', names(cells), value = T)
indicatorVars <- setdiff(indicatorVars, c('is_normal', 'is_dcis'))

toKeep <- c(ptCellVars, proportionVars, phenotypeVars, indicatorVars)
proportionsOut <- cells[, .SD, .SDcols = toKeep]
proportionsOut <- melt(proportionsOut,
	id.vars = c('metabric_id', phenotypeVars, indicatorVars),
	measure.vars = proportionVars,
	value = 'proportion',
	variable = 'type'
	)	
proportionsOut[, type := gsub('proportion_', '', type)]
proportionsOut[type == 'isEpi', 
	type := ifelse(is_epithelial, 'tumour', 'stroma')]
proportionsOut[type == 'isVesselByEpi', 
	type := ifelse(is_vascular, 'vesselByEpi', 'NotVesselByEpi')]
proportionsOut[type == 'isInterfaceByEpi', 
	type := ifelse(is_interface, 'interfaceByEpi', 'NotInterfaceByEpi')]
proportionsOut[grep('ByEpi',type), newSuffix := gsub('[0-9]*', '', meta_id)]
proportionsOut[, type := gsub('ByEpi', '', type)]
proportionsOut[!is.na(newSuffix), type := paste0(type, newSuffix)][,
	newSuffix := NULL]
proportionsOut <- proportionsOut[, .SD[1], by = .(metabric_id, meta_id, type)]
proportionsOut[, type := gsub(' ', '', type)]

proportionsOut[, check := sum(proportion), by = .(metabric_id, type)]
stopifnot(all.equal(rep(1, nrow(proportionsOut)), proportionsOut[['check']]))
proportionsOut[, check := NULL]

saveRDS(proportionsOut, here('scratch/proportions.rds'))
cellPhenotypes <- readRDS(here('scratch/proportions.rds'))
cellPhenotypes <- proportionsOut

cellPhenotypes <- cellPhenotypes[grep('tumour|stroma', type)]
cellPhenotypes <- cellPhenotypes[, .(metabric_id, type, meta_description, proportion)]
allCombinations <- adt(expand.grid(unique(cellPhenotypes[,metabric_id]), unique(cellPhenotypes[,meta_description])))
setnames(allCombinations, c('metabric_id', 'meta_description'))
allCombinations <- merge(x = allCombinations, 
   y = cellPhenotypes[!duplicated(meta_description), .(meta_description, type)], 
   by = 'meta_description') 
cellPhenotypes <- merge(x = allCombinations, y = cellPhenotypes, 
   by = c('metabric_id', 'meta_description', 'type'), all.x = T) 
cellPhenotypes[, meta_description := paste0(meta_description, '_CPh')]
cPh_tumour <- cellPhenotypes[type == 'tumour', unique(meta_description)]
cPh_tme <- cellPhenotypes[type == 'stroma', unique(meta_description)]
cellPhenotypes[is.na(proportion), proportion := 0]
cellPhenotypes[, checkBothCompartments := sum(proportion), by = .(metabric_id, type)]
cellPhenotypes <- cellPhenotypes[checkBothCompartments > 0][, checkBothCompartments := NULL]
cellPhenotypes <- dcast(cellPhenotypes, metabric_id ~ meta_description, value.var = 'proportion')
cellPhenotypes <- na.omit(cellPhenotypes) # samples that contain both tumour and stromal cells
predictors <- merge(x = predictors, y = cellPhenotypes, by = 'metabric_id')


generate_matrix<- function(df, subselection=NULL, NA_percentage=0){
  m <- as.data.frame(df)
  rownames(m) <- m$tnumber
  m <- m[,-c(1)]
  # filtering: with percentages
  m <- m[, which(colMeans(!is.na(m)) > NA_percentage)]
  # Impute NANs before or after scaling?
  # m <- m %>% mutate_all(~ifelse(is.na(.x), mean(.x, na.rm = TRUE), .x))
  
  if (!is.null(subselection)){
    m <- m %>% select(all_of(subselection))
  }
  
  m <- scale(m)
  m <- replace(m,is.na(m),0)
  
  m <- as.data.frame(m)

  return(m)
}

shape_features <- readRDS(here('scratch/shape_parameter_matrix.rds'))
scale_features <- readRDS(here('scratch/scale_parameter_matrix.rds'))
shape_features <- generate_matrix(shape_features,NULL)
scale_features <- generate_matrix(scale_features,NULL)
shape_features$ImageNumber <- rownames(shape_features)
scale_features$ImageNumber <- rownames(scale_features)
clinical_data <- read_csv(here('DATA/IMCClinical.csv'))
clinical_data <- merge(x= clinical_data, unique(cells %>% select(c(ImageNumber, metabric_id))), by='metabric_id', all.x=T)
clinical_data <- clinical_data  %>% select(c(metabric_id, ImageNumber))
shape_features <- merge(shape_features, clinical_data, by='ImageNumber')
scale_features <- merge(scale_features, clinical_data, by='ImageNumber')
shapePredictors <- setdiff(colnames(shape_features), c('metabric_id', 'ImageNumber'))
scalePredictors <- setdiff(colnames(scale_features), c('metabric_id', 'ImageNumber'))

shape_features <- shape_features %>%
  rename_with( .fn = function(.x){paste0("shape_", .x)},
               .cols=all_of(shapePredictors))

scale_features <- scale_features %>%
  rename_with( .fn = function(.x){paste0("scale_", .x)},
               .cols=all_of(scalePredictors))

shapePredictors <- setdiff(colnames(shape_features), c('metabric_id', 'ImageNumber'))
scalePredictors <- setdiff(colnames(scale_features), c('metabric_id', 'ImageNumber'))

predictors <- merge(x = predictors, y = shape_features, by = 'metabric_id')
predictors <- merge(x = predictors, y = scale_features, by = 'metabric_id')


# Response-genomic-vars
clinical_data <- read_csv(here('DATA/IMCClinical.csv'))
intClust <- as.data.table(clinical_data)[, .(metabric_id, IntClust)]
intClust <- intClust[!is.na(IntClust)]
for(i in sortunique(intClust$IntClust)) intClust[, eval(i) := as.numeric(IntClust == i)]
intClust[, IntClust := NULL]

toModel <- merge(x = predictors, y = intClust, by = 'metabric_id', all.x = T)

fitModel <- function(response, predictors, Weights, dt){
	dt <- dt[, .SD, .SDcols = c(response, predictors, Weights)]	
	dt <- na.omit(dt)
	weights <- dt[, get(Weights)]
	response <- as.numeric(dt[, get(response)])
	predictors <- dt[, .SD, .SDcols = predictors]
	lassoFit <- cv.glmnet(as.matrix(predictors), as.matrix(response), weights = weights, 
		family = 'binomial', nlambda = 100, nfolds = 20, alpha = 0)
	return(lassoFit)
}
toModel <- split(toModel, by = 'isTestCohort')
responseVars <- grep('IntClust|amp|del|mut', names(toModel$train), value = T)

getAUC <- function(
	responseVar, # character column name
	predictors, # character vector of column names
	Weights, # character column name
	testTrain # list of dts named 'train' and 'test' 
	){

	sampleSizeTrain <- testTrain$train[!is.na(get(responseVar)), .N]
	samplePositiveTrain <- testTrain$train[get(responseVar) == 1, .N]

	sampleSizeTest <- testTrain$test[!is.na(get(responseVar)), .N]
	samplePositiveTest <- testTrain$test[get(responseVar) == 1, .N]

	modelFit <- fitModel(response = responseVar, predictors = predictors, 
		Weights = Weights, dt = testTrain$train)

	testDt <- testTrain$test[, .SD, .SDcols = c(responseVar, predictors)]
	testDt <- na.omit(testDt)
	testMat <- as.matrix(testDt[, .SD, .SDcols = predictors])
	predictions <- predict(modelFit, testMat, type = 'response', s = 'lambda.min')
	trueLabels <- as.numeric(testDt[, get(responseVar)])
	predictObj <- prediction(predictions, trueLabels)
	auc <- performance(predictObj,"auc") 
	auc <- as.numeric(auc@y.values)
	return(data.table(
		sampleSizeTrain = sampleSizeTrain, samplePositiveTrain = samplePositiveTrain,
		sampleSizeTest = sampleSizeTest, samplePositiveTest = samplePositiveTest,
		response = responseVar, auc = auc))
}

mkAUCsTable <- function(Rep, predictors){
	mkAUC <- function(responseVar, predictors, Weights, testTrain){
		tryCatch(
			expr = {getAUC(responseVar, predictors, Weights, testTrain)},
			error = function(e){print(e)}
			)
	}
	AUCs <- rbindlist(mclapply(responseVars, mkAUC, predictors = predictors, 
		Weights = 'weights', testTrain = toModel, mc.cores = 12))
	AUCs[, rep := Rep]
	return(AUCs)
}

# Fit modeltypes
RNGkind("L'Ecuyer-CMRG")
mc.reset.stream()
doAUCs <- function(predictors){
	Reps <- seq_len(1)
	AUCs <- rbindlist(lapply(Reps, mkAUCsTable, predictors = predictors))
	return(AUCs)
}
TMEStructurePredictors <- grep('TMEStructure[0-9]*', names(predictors), value = TRUE)
AllPredictors <- c(TMEStructurePredictors, nwPredictorsTumour, nwPredictorsTME, shapePredictors,scalePredictors,cPh_tumour, cPh_tme)
distPredictors <- c(shapePredictors, scalePredictors)
AUCs <- lapply(list(cPh_tumour, cPh_tme, TMEStructurePredictors, 
	nwPredictorsTumour, nwPredictorsTME, shapePredictors,scalePredictors,
	distPredictors ,AllPredictors), doAUCs)
names(AUCs) <- c('Cell phenotype (Tumour)', 'Cell phenotype (TME)', 'TME Structures', 
	'Network properties (Tumour)', 'Network properties (TME)','Shape features','Scale features','Shape and scale features', 'Combined')

modeltypes <- seq_len(length(AUCs))
names(modeltypes) <- names(AUCs)
AUCs <- rbindlist(lapply(names(AUCs), function(name){AUCs[[name]][, type := name]}))

AUCs[, facet_by := modeltypes[type]]
AUCs[, facet_by := factor(facet_by, 
	levels = modeltypes, labels = names(modeltypes), ordered = TRUE)]
outfile <- here('scratch/glmnetAUCs.fst')
write_fst(AUCs, outfile)
```

```{r}
# source(here::here('projectHeader.R'))
AUCs <- here('scratch/glmnetAUCs.fst')
AUCs <- read_fst(AUCs, as.data.table = T)

intClustAUCs <- AUCs[grep('IntClust', response)]
# Plot ic10 AUCs
intClustCols <- getSubtypeCols()
intClustCols <- intClustCols$IntClust
intClustAUCs[, yaxis := as.numeric(gsub('IntClust ', '', response))]
intClustAUCs[yaxis > 4, yaxis := yaxis + 2]
intClustAUCs[grep('4\\+', response), yaxis := 4]
intClustAUCs[grep('4\\-', response), yaxis := 5]
intClustAUCs[grep('5\\+', response), yaxis := 6]
intClustAUCs[grep('5\\-', response), yaxis := 7]
intClustAUCs <- intClustAUCs[order(type, yaxis),]

intClustAUCs[, yaxis := factor(yaxis, 
	levels = unique(yaxis), labels = unique(response), ordered = TRUE)]
intClustAUCs[, colours := intClustCols[response]]
intClustAUCs[, yaxis := reorder(yaxis, dplyr::desc(yaxis))]

x <- c("Cell phenotype (Tumour)","Cell phenotype (TME)","TME Structures", "Network properties (Tumour)", "Network properties (TME)","shape features","scale features", "shape and scale features",  "Combined")

intClustAUCs <- intClustAUCs %>%
arrange(sapply(type, function(y) which(y == x)))

aucPlot <- ggplot() +
	geom_vline(xintercept = seq(0.4, 0.8, 0.1), colour = 'lightgrey', size = 0.3) +
	geom_vline(xintercept = 0.5, colour = 'steelblue', size = 0.5, linetype = 'dotted') +
	geom_point(data = intClustAUCs, 
		aes(x = auc, y = yaxis, colour = colours), size = 2.5,
		pch = 21, fill = 'lightgrey') +
	geom_point(data = intClustAUCs[auc > 0.5], 
		aes(x = auc, y = yaxis, fill = colours), size = 3,
		pch = 21, colour = 'black') +
	scale_fill_identity() +
	scale_colour_identity() +
	theme_prj(base_line_size = 0.25) +
	theme(legend.position = 'none',
		panel.background = element_rect(colour = 'black', size = 0.25),
		axis.title.y = element_blank(),
		axis.ticks.y = element_blank(),
		panel.spacing.x = unit(1,'mm'),
		plot.margin = unit(c(0,0.25,0,0), 'mm')) +
	facet_wrap(vars(facet_by), nrow = 1) +
	labs(x = 'AUC')

mkCountBar <- function(DaT){
	barCount <- ggplot(data = DaT) +
		geom_bar( 
			aes(y = samplePositiveTest, x = yaxis), 
			width = 0.8, stat = 'identity', fill = 'grey') +
		geom_text(aes(y = samplePositiveTest, x = yaxis, label = samplePositiveTest), 
			hjust = 0, nudge_y = 1) +
		facet_wrap(vars(facet_by)) +
		theme_prj() +
		theme(strip.text = element_blank(),
			plot.margin = unit(c(0,5,0,0), 'mm'),
			axis.line = element_blank(),
			axis.text = element_blank(),
			axis.ticks = element_blank(),
			axis.title.y = element_blank(),) +
		labs(y = bquote(italic('n')~'tumours')) +
		coord_flip(clip = 'off')
	return(barCount)	
}
barCount <- mkCountBar(intClustAUCs[, .SD[1], by = response])

icOut <- plot_grid(aucPlot, barCount, align = 'h', rel_widths = c(6, 0.4))
outfile <- here('output/Method_comparison/intClustAUCs_ALLfeatures.pdf')
save_plot(outfile, icOut, base_width = 18, base_height = 3)

```
Show top AUCs
```{r}
merge(AUCs %>% group_by(response) %>% summarise(max(auc)), AUCs, by.x='max(auc)',by.y='auc', all.x = T) %>% select(c('max(auc)', 'response.x','type')) %>% arrange(desc(type) )
```


```{r}
# Collect distance features
#TODO
```




## TLS-like structures

There are many ways to compare the methods of Danenberg and Alberto. Here we start by looking at the correlation between TLS-like structures and combination distances in samples. 

```{r TLS}

TLS_structures <- ptLevelInteractions %>% 
  select(ImageNumber, Label, TotalInteractions, nInteractionsPerStructure) %>%
  mutate(proportions =  nInteractionsPerStructure / TotalInteractions) %>%
  filter(Label == 'TLS-like') %>%
  mutate_at(vars(ImageNumber), as.character)

TLS_structures %>%
  filter(proportions > 0) %>%
  ggplot(aes(x=ImageNumber, y=proportions))  +
  geom_point(alpha=0.7, size=2)

TLS_distances <- merge(x=TLS_structures, y= all_parameters, by.x='ImageNumber', by.y='tnumber') %>%
  select(ImageNumber, proportions, phenotype_from, phenotype_to, a,b) %>%
  unite('combi', phenotype_from:phenotype_to, remove = TRUE, sep= '_to_')

splitted_TLS_distances <- split(TLS_distances, f=TLS_distances$combi)

pearson_a = c()
pearson_b = c()
spearman_a = c()
spearman_b = c()

for (c in 1:length(splitted_TLS_distances)){
  tryCatch({
    correlation <- cor.test(splitted_TLS_distances[[c]][['proportions']], splitted_TLS_distances[[c]][['a']] ,  method = "pearson")$estimate[[1]]},
  error=function(e){correlation <- NA})
  pearson_a <- append(pearson_a, correlation)
  tryCatch({
  correlation <- cor.test(splitted_TLS_distances[[c]][['proportions']], splitted_TLS_distances[[c]][['b']] ,  method = "pearson")$estimate[[1]]},
  error=function(e){correlation <- NA})
  pearson_b <- append(pearson_b, correlation)
  tryCatch({
    correlation <- cor.test(splitted_TLS_distances[[c]][['proportions']], splitted_TLS_distances[[c]][['a']] ,  method = "spearman")$estimate[[1]]},
  error=function(e){correlation <- NA})
  spearman_a <- append(spearman_a, correlation)
  tryCatch({
    correlation <- cor.test(splitted_TLS_distances[[c]][['proportions']], splitted_TLS_distances[[c]][['b']] ,  method = "spearman")$estimate[[1]]},
  error=function(e){correlation <- NA})
  spearman_b <- append(spearman_b, correlation)
}

library(ggrepel)

correlations <- tibble('combi'=names(splitted_TLS_distances), 'pearson_a' = pearson_a, 'spearman_a'=spearman_a, 'pearson_b'=pearson_b, 'spearman_b'=spearman_b) %>%
  drop_na()
ggplot(data = correlations, aes(x=pearson_a, y=spearman_a, label=combi)) + geom_point() +
  geom_text_repel(data          = subset(correlations,pearson_a > 0.95),
                  # nudge_y       = 2,
                  nudge_x = 2,
                  size          = 4,
                  box.padding   = 1.5,
                  point.padding = 0.5,
                  force         = 100,
                  segment.size  = 0.5,
                  segment.color = "grey50",
                  direction     = "y") +   xlab('Pearson correlation with shape') + ylab('spearman correlation with shape')

ggplot(data = correlations, aes(x=pearson_b, y=spearman_b, label=combi)) + geom_point() +
  geom_text_repel(data          = subset(correlations,pearson_b > 0.95),
                  # nudge_y       = 2,
                  nudge_x = 2,
                  size          = 4,
                  box.padding   = 1.5,
                  point.padding = 0.5,
                  force         = 100,
                  segment.size  = 0.5,
                  segment.color = "grey50",
                  direction     = "y") +   xlab('Pearson correlation with scale') + ylab('Pearson correlation with scale')



```

```{r}
TLS_cells <- c('CD8^{+} T cells', 'CD4^{+} T cells', 'B cells', 'CD38^{+} lymphocytes', 'Macrophages', 'Fibroblasts', 'Myofibroblasts')

B_cell_correlations <- correlations %>% filter(grepl(paste(TLS_cells, collapse = "|"), combi))


ggplot() + geom_point(data = correlations, aes(x=pearson_a, y=spearman_a)) +xlim(c(-1,1)) +ylim(c(-1,1)) +
  geom_point(data= B_cell_correlations %>% filter(grepl('B cells_to_B cells', combi)), aes(x=pearson_a,y=spearman_a, color=combi),size=3) +
  xlab('Pearson correlation with shape') + ylab('spearman correlation with shape')

ggplot() + geom_point(data = correlations, aes(x=pearson_b, y=spearman_b)) +xlim(c(-1,1)) +ylim(c(-1,1)) +
  geom_point(data= B_cell_correlations %>% filter(grepl('B cells', combi)), aes(x=pearson_b,y=spearman_b, color=combi),size=3) +
  xlab('Pearson correlation with scale') + ylab('Pearson correlation with scale')

```
## Distances in subtypes

```{r}
library(stats)

clinical_data <- read_csv(here('DATA/IMCClinical.csv'))
subtypes <- clinical_data %>% select(c('metabric_id', 'ERStatus', 'PAM50'))

Metabric_mapping <- cells %>% 
                    select(c('ImageNumber', 'metabric_id')) %>% 
                    rename('tnumber' = 'ImageNumber') %>%
                    distinct()

parameters_with_clinical <- merge(x=merge(x=all_parameters, y=Metabric_mapping, by='tnumber', all.x=T),
                                  y= subtypes, by='metabric_id', all.x=T) %>%
                            unite(combi, phenotype_from:phenotype_to, remove = TRUE, sep= '_to_') %>%
                            rename('shape' = 'a', 'scale' = 'b', 'subtype' = "PAM50" ) %>%
                            drop_na() %>%
                            group_by(combi) %>%
                            filter(n() >= 100)

split_parameters_with_clinical <- split(parameters_with_clinical, f=parameters_with_clinical$combi)
p_values = c()

for (c in 1:length(split_parameters_with_clinical)){
  tryCatch({
  one_way <- aov(shape ~ subtype, data = split_parameters_with_clinical[[c]])
  p_value <- summary(one_way)[[1]][["Pr(>F)"]][1]
  }, error=function(e){p_value = NA})
  
  p_values <- append(p_values, p_value)
}

anova_result <- tibble('combi'= names(split_parameters_with_clinical), 'p-value' = p_values) %>% drop_na() %>% arrange(p_values)

for (i in 1:5){
  plts <- ggplot(data = split_parameters_with_clinical[[anova_result[i,"combi"][[1]]]], aes(x=subtype, y=shape)) +
  geom_boxplot() + ggtitle(paste(anova_result[i,"combi"][[1]], ' with p value:', round(anova_result[i,"p-value"][[1]],5)))
  
  
  
  print(plts)
}

  
```

```{r}

p_values = c()
for (c in 1:length(split_parameters_with_clinical)){
  tryCatch({
  one_way <- aov(scale ~ subtype, data = split_parameters_with_clinical[[c]])
  p_value <- summary(one_way)[[1]][["Pr(>F)"]][1]
  }, error=function(e){p_value = NA})
  
  p_values <- append(p_values, p_value)
}

anova_result <- tibble('combi'= names(split_parameters_with_clinical), 'p-value' = p_values) %>% drop_na() %>% arrange(p_values)

for (i in 1:5){
  plts <- ggplot(data = split_parameters_with_clinical[[anova_result[i,"combi"][[1]]]], aes(x=subtype, y=scale)) +
  geom_boxplot() + ggtitle(paste(anova_result[i,"combi"][[1]], ' with p value:', round(anova_result[i,"p-value"][[1]],5)))
  
  print(plts)
}


```

