---
title: "predictions"
author: "Niek Brouwer"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Logistic regression

In this document we are going to predict subtypes based on the feature sets using logistic regression.

```{r}
library(tidyverse)
library(ggplot2)
library(data.table)
library(parallel)
library(here)
library(fst)
library(assertthat)
library(RColorBrewer)
library(cowplot)
library(ggpubr)
library(gtools)
source(here("UtilityFunctions.R"))
source(here('MEP_UtilityFunctions.R'))
source(here('logisticRegression_methods.R'))
library('glmnet', quiet = T)
library(glmnetUtils)
library('ROCR', quiet = T)
library(ComplexHeatmap)
library(caret)
library(pROC)
library(helfRlein)
library(splitTools)

# set seed
projectSeed <- 89230689
set.seed(projectSeed)

outDir <- here('scratch')
cells <- getCellsAlternative()
structures <- getStructures()
TMEStructures <- read_fst(here('scratch/TMEStructures.fst'), as.data.table=T)
ptLevelTMEinteractions <- read_fst(here('scratch/ptLeveLTMEInteractions.fst'), as.data.table=T)
NetworkProperties <- readRDS(here('scratch/NetworkProperties.rds'))
clinical_data <- getClinical()
init_predictors <- predictorInitialFile()
# colnames(init_predictors) <- gsub("[^A-Za-z0-9+\\-]", "", colnames(init_predictors))

```

The training dataset increases in size because the shape and scale parameters are computed per image instead of per patient. It also considers tissues with only tumor or only TME cells. These images are removed in the originial prediction experiment.

Calculate TME structures, proportions and network properties per slide instead of sample.

```{r}
TMEStructurePredictors <- c("TMEStructure1", "TMEStructure2", "TMEStructure3", "TMEStructure4", "TMEStructure5", "TMEStructure6", "TMEStructure7", "TMEStructure8", "TMEStructure9", "TMEStructure10")

cellPhenotypes <- here('scratch/cellPhenotypeProportionsAlternative.fst')
cellPhenotypes <- read_fst(cellPhenotypes, as.data.table = T)
cellPhenotypes <- cellPhenotypes[grep('tumour|stroma', type)]
cellPhenotypes <- cellPhenotypes[, .(ImageNumber, type, meta_description, proportion)]
allCombinations <- adt(expand.grid(unique(cellPhenotypes[,ImageNumber]), unique(cellPhenotypes[,meta_description])))
setnames(allCombinations, c('ImageNumber', 'meta_description'))
allCombinations <- merge(x = allCombinations, 
                         y = cellPhenotypes[!duplicated(meta_description), .(meta_description, type)], 
                         by = 'meta_description') 
cellPhenotypes <- merge(x = allCombinations, y = cellPhenotypes, 
                        by = c('ImageNumber', 'meta_description', 'type'), all.x = T) 
# cellPhenotypes[, meta_description := paste0(meta_description, '_CPh')]
cPh_tumour <- cellPhenotypes[type == 'tumour', unique(meta_description)]
cPh_tme <- cellPhenotypes[type == 'stroma', unique(meta_description)]

cellPhenotypes <- here('scratch/cellPhenotypeProportions.fst')
cellPhenotypes <- read_fst(cellPhenotypes, as.data.table = T)
cellPhenotypes <- cellPhenotypes[grep('tumour|stroma', type)]
cellPhenotypes <- cellPhenotypes[, .(ImageNumber, type, meta_description, proportion)]
allCombinations <- adt(expand.grid(unique(cellPhenotypes[,ImageNumber]), unique(cellPhenotypes[,meta_description])))
setnames(allCombinations, c('ImageNumber', 'meta_description'))
allCombinations <- merge(x = allCombinations, 
                         y = cellPhenotypes[!duplicated(meta_description), .(meta_description, type)], 
                         by = 'meta_description') 
cellPhenotypes <- merge(x = allCombinations, y = cellPhenotypes, 
                        by = c('ImageNumber', 'meta_description', 'type'), all.x = T) 
cellPhenotypes[, meta_description := gsub("[^A-Za-z0-9+\\-]", "", meta_description)]
cellPhenotypes[, meta_description := paste0(meta_description, '_originalType')]
cPh_tumour_original <- cellPhenotypes[type == 'tumour', unique(meta_description)]
cPh_tme_original <- cellPhenotypes[type == 'stroma', unique(meta_description)]

nwP <- here('scratch/NetworkProperties.rds')
nwP <- read_rds(nwP)
standardiseNwP <- function(name){
  dt <- nwP[[name]]
  setnames(dt, grep('communities_', names(dt), value = TRUE), 'communityID')
  dt[, type := name]
  return(dt)
}
nwP <- rbindlist(lapply(c('stroma', 'tumour'), standardiseNwP))
IDs <- getCells()[, .(ImageNumber, metabric_id)][, .SD[1], by = ImageNumber]
nwP <- merge(x = nwP, y = IDs, by = 'ImageNumber') 
nwP[, assortativity := NULL] #has NAs
measureVars <- grep('ImageNumber|communityID|type|metabric_id', names(nwP), 
                    invert = TRUE, value = TRUE)
PtmeasureVars <- paste0(measureVars, 'PtMean')
nwP[, eval(PtmeasureVars) := lapply(.SD, mean), by = .(type, ImageNumber), .SDcols = measureVars]
nwP <- nwP[, .SD[1], by = .(type, ImageNumber)]
nwP <- nwP[, .SD, .SDcols = c('ImageNumber', 'type', PtmeasureVars)]
nwP <- melt(nwP, id.vars = c('ImageNumber', 'type'))
nwP[, variable := paste0(variable, '_', type)]
nwP <- dcast(nwP, ImageNumber ~ variable)
nwP <- na.omit(nwP)
nwPredictorsTumour <- grep('_tumour', names(nwP), invert = F, value = T)
nwPredictorsTME <- grep('_stroma', names(nwP), invert = F, value = T)

rm(nwP, cellPhenotypes)

```

Test different filters.

```{r}
toModel <- apply_filtering(init_predictors, 100)
#use 70% of dataset as training set and 30% as test set
toModel_clinical <- (clinical_data %>% filter(ImageNumber %in% toModel$ImageNumber))
folds <- create_folds(toModel_clinical$PAM50, k = 5)

for (percentage in seq(100,5,-5)){
  for (i in 1:length(folds)){
    train <- toModel_clinical[folds[[i]], ] %>% pull(ImageNumber)
    
    toModel <- apply_filtering(init_predictors, percentage)
    toModel <- toModel %>% mutate(isTestCohort = ifelse(ImageNumber %in% train, 'train','test'))
    toModel <- split(toModel, by = 'isTestCohort')

    shapePredictors <- grep('shape', names(toModel$train), value = T)
    scalePredictors <- grep('scale', names(toModel$train), value = T)
    distPredictors <- grep('shape|scale', names(toModel$train), value = T)
    distance_predictors <- list(shapePredictors,scalePredictors,distPredictors)
    name_distance_predictors <-  c('Shape features','Scale features','Shape and scale features')
    
    responseVars <- c('Luminal A','Luminal B', 'HER2', 'Basal', 'Normal-like')
    outputfile = paste(here('scratch/glmnetAUCs_PAM_'),percentage, 'filter_test',i , '.fst',sep='')
    fitAndEstimate(distance_predictors,name_distance_predictors, outfile = outputfile, df= toModel)
    
  }
}


toModel <- apply_filtering(init_predictors, 100)
#use 70% of dataset as training set and 30% as test set
toModel_clinical <- (clinical_data %>% filter(ImageNumber %in% toModel$ImageNumber))
folds <- create_folds(toModel_clinical$ER_HER2_status, k = 5)

for (percentage in seq(100,5,-5)){
  for (i in 1:length(folds)){
    train <- toModel_clinical[folds[[i]], ] %>% pull(ImageNumber)
    
    toModel <- apply_filtering(init_predictors, percentage)
    toModel <- toModel %>% mutate(isTestCohort = ifelse(ImageNumber %in% train, 'train','test'))
    toModel <- split(toModel, by = 'isTestCohort')

    shapePredictors <- grep('shape', names(toModel$train), value = T)
    scalePredictors <- grep('scale', names(toModel$train), value = T)
    distPredictors <- grep('shape|scale', names(toModel$train), value = T)
    distance_predictors <- list(shapePredictors,scalePredictors,distPredictors)
    name_distance_predictors <-  c('Shape features','Scale features','Shape and scale features')
    
    responseVars <- c("ER+HER2-", "ER-HER2-", "ER+HER2+", "ER-HER2+")
    outputfile = paste(here('scratch/glmnetAUCs_MS_'),percentage, 'filter_test',i , '.fst',sep='')
    fitAndEstimate(distance_predictors,name_distance_predictors, outfile = outputfile, df= toModel)
    
  }
}

```

Rerun the experiments with cross-validation for all other feature sets.

```{r}
filtering_percentage <- 100

toModel <- apply_filtering(init_predictors, filtering_percentage)
#use 70% of dataset as training set and 30% as test set
toModel_clinical <- (clinical_data %>% filter(ImageNumber %in% toModel$ImageNumber))
folds <- create_folds(toModel_clinical$PAM50, k = 5)

for (i in 1:length(folds)){
  train <- toModel_clinical[folds[[i]], ] %>% pull(ImageNumber)
  
  toModel <- apply_filtering(init_predictors, 100)
  toModel <- toModel %>% mutate(isTestCohort = ifelse(ImageNumber %in% train, 'train','test'))
  toModel <- split(toModel, by = 'isTestCohort')

  shapePredictors <- grep('shape', names(toModel$train), value = T)
  scalePredictors <- grep('scale', names(toModel$train), value = T)
  distPredictors <- grep('shape|scale', names(toModel$train), value = T)
  AllPredictors <- c(cPh_tumour, cPh_tme, shapePredictors,scalePredictors)
  all_predictors <- list(cPh_tumour, cPh_tme, TMEStructurePredictors,	nwPredictorsTumour, nwPredictorsTME, shapePredictors, scalePredictors, distPredictors, AllPredictors)
name_predictors <-  c('Cell phenotype (Tumour)', 'Cell phenotype (TME)', 'TME Structures','Network properties (Tumour)', 'Network properties (TME)','Shape features','Scale features','Shape and scale features', 'Combined')
 
  responseVars <- c('Luminal A','Luminal B', 'HER2', 'Basal', 'Normal-like')
  outputfile = paste(here('scratch/glmnetAUCs_PAM_crossvalidation_lasso_test'), i, '.fst', sep='')
  
  fitAndEstimate(all_predictors,name_predictors, outfile = outputfile, df = toModel)
  
}

toModel <- apply_filtering(init_predictors, filtering_percentage)
toModel_clinical <- (clinical_data %>% filter(ImageNumber %in% toModel$ImageNumber))
folds <- create_folds(toModel_clinical$ER_HER2_status, k = 5)

for (i in 1:length(folds)){
  train <- toModel_clinical[folds[[i]], ] %>% pull(ImageNumber)
  
  toModel <- apply_filtering(init_predictors, 100)
  toModel <- toModel %>% mutate(isTestCohort = ifelse(ImageNumber %in% train, 'train','test'))
  toModel <- split(toModel, by = 'isTestCohort')
  
  shapePredictors <- grep('shape', names(toModel$train), value = T)
  scalePredictors <- grep('scale', names(toModel$train), value = T)
  distPredictors <- grep('shape|scale', names(toModel$train), value = T)
  AllPredictors <- c(cPh_tumour, cPh_tme, shapePredictors,scalePredictors)
  all_predictors <- list(cPh_tumour, cPh_tme, TMEStructurePredictors,	nwPredictorsTumour, nwPredictorsTME, shapePredictors, scalePredictors, distPredictors, AllPredictors)
name_predictors <-  c('Cell phenotype (Tumour)', 'Cell phenotype (TME)', 'TME Structures','Network properties (Tumour)', 'Network properties (TME)','Shape features','Scale features','Shape and scale features', 'Combined')
  
  responseVars <- c("ER+HER2-", "ER-HER2-", "ER+HER2+", "ER-HER2+")
  outputfile = paste(here('scratch/glmnetAUCs_MS_crossvalidation_test'), i, '.fst', sep='')
  
  fitAndEstimate(all_predictors,name_predictors, outfile = outputfile, df = toModel)
}

```
Also predict based on original cell type density features.
```{r}
source(here('logisticRegression_methods.R'))

filtering_percentage <- 100

toModel <- apply_filtering(init_predictors, filtering_percentage)
#use 70% of dataset as training set and 30% as test set
toModel_clinical <- (clinical_data %>% filter(ImageNumber %in% toModel$ImageNumber))
folds <- create_folds(toModel_clinical$PAM50, k = 5)

for (i in 1:length(folds)){
  train <- toModel_clinical[folds[[i]], ] %>% pull(ImageNumber)
  
  toModel <- apply_filtering(init_predictors, 100)
  toModel <- toModel %>% mutate(isTestCohort = ifelse(ImageNumber %in% train, 'train','test'))
  toModel <- split(toModel, by = 'isTestCohort')
  shapePredictors <- grep('shape', names(toModel$train), value = T)
  scalePredictors <- grep('scale', names(toModel$train), value = T)

  all_predictors <- list(cPh_tumour_original, cPh_tme_original)
  name_predictors <-  c('Original cell phenotype (Tumour)', 'Original cell phenotype (TME)')
 
  responseVars <- c('Luminal A','Luminal B', 'HER2', 'Basal', 'Normal-like')
  outputfile = paste(here('scratch/glmnetAUCs_PAM_crossvalidation_original_test'), i, '.fst', sep='')
  
  fitAndEstimate(all_predictors,name_predictors, outfile = outputfile, df = toModel)
  
}

toModel <- apply_filtering(init_predictors, filtering_percentage)
toModel_clinical <- (clinical_data %>% filter(ImageNumber %in% toModel$ImageNumber))
folds <- create_folds(toModel_clinical$ER_HER2_status, k = 5)

for (i in 1:length(folds)){
  train <- toModel_clinical[folds[[i]], ] %>% pull(ImageNumber)
  
  toModel <- apply_filtering(init_predictors, 100)
  toModel <- toModel %>% mutate(isTestCohort = ifelse(ImageNumber %in% train, 'train','test'))
  toModel <- split(toModel, by = 'isTestCohort')
  
  all_predictors <- list(cPh_tumour_original, cPh_tme_original)
  name_predictors <-  c('Original cell phenotype (Tumour)', 'Original cell phenotype (TME)')

  responseVars <- c("ER+HER2-", "ER-HER2-", "ER+HER2+", "ER-HER2+")
  outputfile = paste(here('scratch/glmnetAUCs_MS_crossvalidation_original_test'), i, '.fst', sep='')
  
  fitAndEstimate(all_predictors,name_predictors, outfile = outputfile, df = toModel)
}
```



### Final predictions
Rerun the experiment while saving rocs and coefficient lists.

```{r}
toModel <- apply_filtering(init_predictors, 100)
toModel <- split(toModel, by = 'isTestCohort')
responseVars <- c("ER+HER2-", "ER-HER2-", "ER+HER2+", "ER-HER2+")
responseVars <- c(responseVars, c('Luminal A','Luminal B', 'HER2', 'Basal', 'Normal-like'))
shapePredictors <- grep('shape', names(toModel$train), value = T)
scalePredictors <- grep('scale', names(toModel$train), value = T)
distPredictors <- grep('shape|scale', names(toModel$train), value = T)
AllPredictors <- c(cPh_tumour, cPh_tme, shapePredictors,scalePredictors)

all_predictors <- list(cPh_tumour, cPh_tme,cPh_tumour_original,cPh_tme_original, TMEStructurePredictors,	nwPredictorsTumour, nwPredictorsTME, shapePredictors,scalePredictors,distPredictors ,AllPredictors)
name_predictors <-  c('Cell phenotype (Tumour)', 'Cell phenotype (TME)','Original cell phenotype (Tumour)', 'Original cell phenotype (TME)', 'TME Structures',
  	'Network properties (Tumour)', 'Network properties (TME)','Shape features','Scale features','Shape and scale features', 'Combined')

outputfile = here('scratch/glmnetAUCs_ALL_crossvalidation_v4.fst')

fitAndEstimate(all_predictors,name_predictors, outfile = outputfile, df = toModel) 
```

## Plot AUCs
Show effect of filtering on AUCs.

```{r}

MS_allAUCs <- data.frame(matrix(nrow = 0, ncol=12))
pam_allAUCs <- data.frame(matrix(nrow = 0, ncol=12))
for (s in seq(100, 5, -5)){
  for (t in seq(1,5,1)){
      file = paste(here('scratch/glmnetAUCs_MS_'), s, 'filter_test', t, '.fst', sep='')
      MS_allAUCs <- rbind(MS_allAUCs, collect_MolecularSubtypes(file) %>% mutate(colours = s))
      file = paste(here('scratch/glmnetAUCs_PAM_'), s, 'filter_test', t, '.fst', sep='')
      pam_allAUCs <- rbind(pam_allAUCs, collect_pam(file) %>% mutate(colours = s))
    
  }
}

p <- plot_grid(generate_plot_filtering(MS_allAUCs),generate_plot_filtering(pam_allAUCs), ncol = 1)
save_plot(here('output/Method_comparison/logistic_regression/intclustAndPAM_AUCs_filtering_run2.pdf'), p, base_width = 12, base_height = 6)

p <- plot_grid(generate_plot_alphas(MS_allAUCs),generate_plot_alphas(pam_allAUCs), ncol = 1)
save_plot(here('output/Method_comparison/logistic_regression/intclustAndPAM_AUCsWithAlphas_filtering_run2.pdf'), p, base_width = 12, base_height = 6)

```

```{r}
MS_allAUCs_means <- MS_allAUCs %>% group_by(response, type,colours,yaxis,facet_by) %>% summarise(mean_auc = mean(auc), sd_auc = sd(auc)) %>% mutate(moe =  qnorm(0.975)*sd_auc/sqrt(5))
pam_allAUCs_means <- pam_allAUCs %>% group_by(response, type,colours,yaxis,facet_by) %>% summarise(mean_auc = mean(auc), sd_auc = sd(auc)) %>% mutate(moe =  qnorm(0.975)*sd_auc/sqrt(5))

ggplot(pam_allAUCs_means)  +
  # geom_ribbon(aes(x=colours, ymin=mean_auc-moe, ymax=mean_auc+moe,colour=facet_by,fill=facet_by), width=.2,position=position_dodge(0.05),alpha=0.2) +
  geom_line(aes(x=colours, y=mean_auc, colour=facet_by),alpha=0.8) + geom_point(aes(x=colours, y=mean_auc, colour=facet_by),alpha=0.8) +
  facet_wrap(~fct_rev(yaxis),nrow=1)  + xlab('% of features included') + xlim(100,0) + theme_bw()
ggsave(here('output/Method_comparison/logistic_regression/PAM_filtervsauc_run2.pdf'),height=4, width=12)

ggplot(MS_allAUCs_means) + 
  # geom_ribbon(aes(x=colours, ymin=mean_auc-moe, ymax=mean_auc+sd_moe,colour=facet_by,fill=facet_by), width=.2,position=position_dodge(0.05),alpha=0.2) +
  geom_line(aes(x=colours, y=mean_auc, colour=facet_by),alpha=0.8) + geom_point(aes(x=colours, y=mean_auc, colour=facet_by),alpha=0.8) +
 facet_wrap(~fct_rev(yaxis),nrow=1)  + xlab('% of features included') + xlim(100,0) + theme_bw()
ggsave(here('output/Method_comparison/logistic_regression/MS_filtervsauc_run2.pdf'),height=4, width=10)
```

AUCs don't improve and often get worse with this type of filtering.
The information lays in common AND rare features. We use all features with elasticnet as lasso can neglect features.


## AUC improvement significance
https://www.rdocumentation.org/packages/
pROC/versions/1.18.0/topics/roc.test
https://www.r-bloggers.com/2018/12/statistical-assessments-of-auc/

```{r}
# response_types <- c("IntClust 1", "IntClust 2", "IntClust 3","IntClust 4-", "IntClust 4+",
#            "IntClust 5-", "IntClust 5+", "IntClust 6",  "IntClust 7", "IntClust 8",  "IntClust 9","IntClust 10",
#            "Basal", "HER2", "Luminal A", "Luminal B", "Normal-like")
# response_labels <- c("IntClust 1", "IntClust 2", "IntClust 3", "IntClust 4+","IntClust 4-",
#             "IntClust 5+", "IntClust 5-","IntClust 6",  "IntClust 7", "IntClust 8",  "IntClust 9","IntClust 10",
#            "Luminal A","Luminal B","HER2","Basal" , "Normal-like")
# 
# x <- c("Shape features","Scale features")
# 
# prediction_types <- c('shape', 'scale')
# convert_predictors <- tibble(name = prediction_types, df_name = x )
# 
# lengths <- c(988, 938,889,839,790,741,691,642,592,543,494,444,395,345,296,247,197,148,98,49)
# percentages <- seq(100,5,-5)
# df <- tibble(filtertype = lengths, p = percentages)
# 
# compare_rocs <- function(fileA, fileB){
#     roc1 <- readRDS(fileA)
#     roc2 <- readRDS(fileB)
# 
#     return(pROC::roc.test(roc1, roc2, method = "bootstrap", boot.n = 500, progress = "none", paired = T))
# }
# 
# filter_pvalues = data.frame(matrix(nrow=0, ncol=6,))
# for (response in response_types){
#   for (pred in prediction_types){
#         path <-  paste(here('scratch/ROCS/'),pred, '/',sep='')
#         files <- grep(paste(response,'_',sep=''),list.files(path = path),fixed=T,value=T)
#         zerofilter_file <- grep('filter988',files,fixed=T,value=T)
#         print(zerofilter_file)
#         files <- files[files != zerofilter_file]
#         for (f in 1:length(files)){
#           r1 <- compare_rocs(paste(here('scratch/ROCS/'), pred, '/', zerofilter_file,sep=''),paste(here('scratch/ROCS/'), pred, '/', files[[f]],sep=''))
#           v1 <- c(as.numeric(r1[['p.value']]), as.numeric(r1[['estimate']]), response,
#                   convert_predictors %>% filter(name == pred) %>% pull(df_name),
#                   (str_split(str_split(files[[f]], 'filter')[[1]][[2]],'_')[[1]][[1]]))
#         filter_pvalues <- rbind(filter_pvalues,v1)
#         }
#     }
#   }
# 
# filter_pvalues <- setNames(filter_pvalues, c('p_value', 'AUC_nofilter', 'AUC_filter', 'response', 'type', 'filtertype'))
# filter_pvalues <- merge(filter_pvalues, df, by = 'filtertype')
# filter_pvalues <- filter_pvalues %>% distinct(response, p,type, .keep_all = TRUE)
# saveRDS(filter_pvalues, here('scratch/filter_pvalues.rds'))
```

```{r}
# filter_pvalues <- read_rds(here('scratch/filter_pvalues.rds'))
# filter_pvalues <- filter_pvalues %>% distinct(response, p,type, .keep_all = TRUE)
# filter_pvalues <- filter_pvalues %>% filter(type == 'Shape features')
# filter_pvalues <- filter_pvalues %>% mutate(sign = ifelse(as.numeric(format(p_value, scientific = FALSE)) < 0.05 & as.numeric(AUC_nofilter) > as.numeric(AUC_filter), "significant loss", NA))
# filter_pvalues <- filter_pvalues %>% mutate(sign = ifelse(as.numeric(format(p_value, scientific = FALSE)) < 0.05 & as.numeric(AUC_nofilter) < as.numeric(AUC_filter), "significant improvement", sign))
# 
# ggplot(filter_pvalues, aes(p, response))  + geom_tile(aes(fill = abs(as.numeric(p_value)), color=sign, width=3.7, height=0.7),size=2) + 
#   ylim(rev(response_labels)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
# panel.background = element_blank(), axis.line = element_line(colour = "black")) + 
#   geom_text(aes(label = round(as.numeric(p_value), 6)),size=1)  +
#   scale_fill_gradientn(colours=c("blue", "white"),na.value = 'grey98', limits = c(0,0.05),name='p-value') + 
#   scale_colour_manual(values=c("green", "red"),na.translate = F,name='') +
#   xlim(100,0) + xlab('percentage of features included') + ggtitle('Performances with shape features')
#  
# ggsave(here('output/Method_comparison/logistic_regression/filter_evaluation_shape.pdf'),width=10, height=8)
# 
# filter_pvalues <- read_rds(here('scratch/filter_pvalues.rds'))
# filter_pvalues <- filter_pvalues %>% distinct(response, p,type, .keep_all = TRUE)
# filter_pvalues <- filter_pvalues %>% filter(type == 'Scale features')
# filter_pvalues <- filter_pvalues %>% mutate(sign = ifelse(as.numeric(format(p_value, scientific = FALSE)) < 0.05 & as.numeric(AUC_nofilter) > as.numeric(AUC_filter), "significant loss", NA))
# filter_pvalues <- filter_pvalues %>% mutate(sign = ifelse(as.numeric(format(p_value, scientific = FALSE)) < 0.05 & as.numeric(AUC_nofilter) < as.numeric(AUC_filter), "significant improvement", sign))
# 
# ggplot(filter_pvalues, aes(p, response))  + geom_tile(aes(fill = abs(as.numeric(p_value)), color=sign, width=3.7, height=0.7),size=2) + 
#   ylim(rev(response_labels)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
# panel.background = element_blank(), axis.line = element_line(colour = "black")) + 
#   geom_text(aes(label = round(as.numeric(p_value), 6)),size=1)  +
#   scale_fill_gradientn(colours=c("blue", "white"),na.value = 'grey98', limits = c(0,0.05),name='p-value') + 
#   scale_colour_manual(values=c("green", "red"),na.translate = F,name='') +
#   xlim(100,0) + xlab('percentage of features included') + ggtitle('Performances with scale features')
#  
# ggsave(here('output/Method_comparison/logistic_regression/filter_evaluation_scale.pdf'),width=10, height=8)

```


```{r}
# filter_shapescale_pvalues = data.frame(matrix(nrow=0, ncol=6))
# for (response in response_types){
#   for (pred in c('shape_and_scale')){
#         path <-  paste(here('scratch/ROCS/'),pred, '/',sep='')
#         files <- grep(paste(response,'_',sep=''),list.files(path = path),fixed=T,value=T)
#         zerofilter_file <- grep('filter1976',files,fixed=T,value=T)
#         print(zerofilter_file)
#         files <- files[files != zerofilter_file]
#         for (f in 1:length(files)){
#           r1 <- compare_rocs(paste(here('scratch/ROCS/'), pred, '/', zerofilter_file,sep=''),paste(here('scratch/ROCS/'), pred, '/', files[[f]],sep=''))
#           v1 <- c(as.numeric(r1[['p.value']]), as.numeric(r1[['estimate']]), response,
#                   convert_predictors %>% filter(name == pred) %>% pull(df_name),
#                   (str_split(str_split(files[[f]], 'filter')[[1]][[2]],'_')[[1]][[1]]))
#         filter_shapescale_pvalues <- rbind(filter_shapescale_pvalues,v1)
#         }
#     }
#   }
# 
# lengths <- 2 * c(988, 938,889,839,790,741,691,642,592,543,494,444,395,345,296,247,197,148,98,49)
# percentages <- seq(100,5,-5)
# df <- tibble(filtertype = lengths, p = percentages)
# 
# filter_shapescale_pvalues <- setNames(filter_shapescale_pvalues, c('p_value', 'AUC_nofilter', 'AUC_filter', 'response', 'filtertype'))
# filter_shapescale_pvalues <- merge(filter_shapescale_pvalues, df, by = 'filtertype',all.x=T)
# filter_shapescale_pvalues <- filter_shapescale_pvalues %>% distinct(response, p, .keep_all = TRUE)
# saveRDS(filter_shapescale_pvalues, here('scratch/filter_shapescale_pvalues.rds'))

```

```{r}
# filter_pvalues <- read_rds(here('scratch/filter_shapescale_pvalues.rds'))
# filter_pvalues <- filter_pvalues %>% mutate(sign = ifelse(as.numeric(format(p_value, scientific = FALSE)) < 0.05 & as.numeric(AUC_nofilter) > as.numeric(AUC_filter), "significant loss", NA))
# filter_pvalues <- filter_pvalues %>% mutate(sign = ifelse(as.numeric(format(p_value, scientific = FALSE)) < 0.05 & as.numeric(AUC_nofilter) < as.numeric(AUC_filter), "significant improvement", sign))
# 
# ggplot(filter_pvalues, aes(p, response))  + geom_tile(aes(fill = abs(as.numeric(p_value)), color=sign, width=3.7, height=0.7),size=2) + 
#   ylim(rev(response_labels)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
# panel.background = element_blank(), axis.line = element_line(colour = "black")) + 
#   geom_text(aes(label = round(as.numeric(p_value), 6)),size=1)  +
#   scale_fill_gradientn(colours=c("blue", "white"),na.value = 'grey98', limits = c(0,0.05),name='p-value') + 
#   scale_colour_manual(values=c("green", "red"),na.translate = F,name='') +
#   xlim(100,0) + xlab('percentage of features included') + ggtitle('Performances with shape and scale features')
#  
# ggsave(here('output/Method_comparison/logistic_regression/filter_evaluation_shapescale.pdf'),width=10, height=8)

```

Plot results of predictions with all features and show the deviation of the AUC when testing the models with stratified 5-fold (on PAM50 subtypes)

```{r}
MS_allAUCs <- data.frame(matrix(nrow = 0, ncol=12))
pam_allAUCs <- data.frame(matrix(nrow = 0, ncol=12))
  for (t in seq(1,5,1)){
      file = paste(here('scratch/LR_models_run2/glmnetAUCs_MS_crossvalidation_test'), t, '.fst', sep='')
      MS_allAUCs <- rbind(MS_allAUCs, collect_MolecularSubtypes(file) %>% mutate(type = t))
      file = paste(here('scratch/LR_models_run2/glmnetAUCs_PAM_crossvalidation_test'), t, '.fst', sep='')
      pam_allAUCs <- rbind(pam_allAUCs, collect_pam(file) %>% mutate(type = t))
  }

for (t in seq(1,5,1)){
      file = paste(here('scratch/glmnetAUCs_MS_crossvalidation_original_test'), t, '.fst', sep='')
      MS_allAUCs <- rbind(MS_allAUCs, collect_MolecularSubtypes(file) %>% mutate(type = t))
      file = paste(here('scratch/glmnetAUCs_PAM_crossvalidation_original_test'), t, '.fst', sep='')
      pam_allAUCs <- rbind(pam_allAUCs, collect_pam(file) %>% mutate(type = t))
  
}

```

Show final performance on fixed train/test set.

```{r}
file = here('scratch/glmnetAUCs_ALL_crossvalidation_v4.fst')
MS_allAUCs <- rbind(MS_allAUCs, collect_MolecularSubtypes(file) %>% mutate(type = 'test_set'))
pam_allAUCs <- rbind(pam_allAUCs, collect_pam(file) %>% mutate(type = 'test_set'))

p <- plot_grid(generate_plot_withboxplot(MS_allAUCs %>% filter(facet_by %in% c('Original cell phenotype (TME)', 'Original cell phenotype (Tumour)', 'Cell phenotype (Tumour)','Cell phenotype (TME)'))),generate_plot_withboxplot(pam_allAUCs %>% filter(facet_by %in% c('Original cell phenotype (TME)', 'Original cell phenotype (Tumour)', 'Cell phenotype (Tumour)','Cell phenotype (TME)'))), ncol = 1)
save_plot(here('output/Method_comparison/logistic_regression/MSAndPAM_AUCs_densities_run2.pdf'), p, base_width = 10, base_height = 6)

p <- plot_grid(generate_plot_withboxplot(MS_allAUCs %>% filter(!(facet_by %in% c('Original cell phenotype (TME)', 'Original cell phenotype (Tumour)')))),generate_plot_withboxplot(pam_allAUCs  %>% filter(!(facet_by %in% c('Original cell phenotype (TME)', 'Original cell phenotype (Tumour)')))), ncol = 1)
save_plot(here('output/Method_comparison/logistic_regression/MSAndPAM_AUCs_ALL_run2.pdf'), p, base_width = 18, base_height = 6)
```


Compare AUCs with selected alphas and 0, 1.

```{r}
# AUCs <- here('scratch/glmnetAUCs_ALL_crossvalidation_v3.fst')
# AUCs_lasso <- here('scratch/glmnetAUCs_lasso_nofilter.fst')
# AUCs_ridge <- here('scratch/glmnetAUCs_ridge_nofilter.fst')
# 
# # intclust_allAUCs <- c(collect_intclust(AUCs) %>% mutate(colours = 'cross_validation'))
# # pam_allAUCs <- c(collect_pam(AUCs) %>% mutate(colours = 'cross_validation'))
# intclust_allAUCs <- as.data.frame(matrix(nrow=0, ncol=12))
# pam_allAUCs <- as.data.frame(matrix(nrow=0, ncol=12))
# intclust_allAUCs <- rbind(intclust_allAUCs, collect_intclust(AUCs_lasso) %>% mutate(colours = 'lasso') %>% mutate(alpha = 1))
# pam_allAUCs <- rbind(pam_allAUCs, collect_pam(AUCs_lasso) %>% mutate(colours = 'lasso') %>% mutate(alpha = 1)) 
# intclust_allAUCs <- rbind(intclust_allAUCs, collect_intclust(AUCs_ridge) %>% mutate(colours = 'ridge') %>% mutate(alpha=0))
# pam_allAUCs <- rbind(pam_allAUCs, collect_pam(AUCs_ridge) %>% mutate(colours = 'ridge') %>% mutate(alpha=0))
# 
# p <- plot_grid(generate_plot_alphas(intclust_allAUCs),generate_plot_alphas(pam_allAUCs), ncol = 1)
# save_plot(here('output/Method_comparison/logistic_regression/intclustAndPAM_AUCs_ALL_lassoridge.pdf'), p, base_width = 19.5, base_height = 6)


```

Why does AUC of TME with network properties change with filtering? --> random effect

```{r}
# AUCs_1 <- here('scratch/glmnetAUCs_onlynetworkTME.fst')
# AUCs_2 <- here('scratch/glmnetAUCs_onlynetworkTME2.fst')
# AUCs_3 <- here('scratch/glmnetAUCs_onlynetworkTME3.fst')
# AUCs_4 <- here('scratch/glmnetAUCs_onlynetworkTME4.fst')
# AUCs_5 <- here('scratch/glmnetAUCs_onlynetworkTME5.fst')
# 
# selection <- c(AUCs_1, AUCs_2, AUCs_3, AUCs_4, AUCs_5)
# selection_titles <- c('1','2','3','4','5')
# 
# intclust_allAUCs <- c(collect_intclust(selection[1]) %>% mutate(method = selection_titles[1]))
# pam_allAUCs <- c(collect_pam(selection[1]) %>% mutate(method = selection_titles[1]))
# for (s in 2:length(selection)){
#   intclust_allAUCs <- rbind(intclust_allAUCs, collect_intclust(selection[s]) %>% mutate(method = selection_titles[s]))
#   pam_allAUCs <- rbind(pam_allAUCs, collect_pam(selection[s]) %>% mutate(method = selection_titles[s]))
# 
# }
# 
# p <- plot_grid(generate_plot(intclust_allAUCs),generate_plot(pam_allAUCs), ncol = 1)
# save_plot(here('output/Method_comparison/logistic_regression/intclustAndPAM_AUCs_overlay_networktumor.pdf'), p, base_width = 6, base_height = 6)
```


```{r}
# plot_rocs <- function(response, predictorA, alphaA, filterA){
#     fileA <- paste(here('scratch/ROCS/roc_'),alphaA,'_', filterA,'_', response, '_', predictorA, '.rds', sep='')
#     dfA <- readRDS(fileA)
#     roc1 <- pROC::roc(factor(c(as.numeric(unlist(dfA[2]))), levels=c(0,1)) ~ c(as.numeric(unlist(dfA[1]))), direction = "<")
#     plot(roc1,legacy.axes=TRUE, print.auc=TRUE)
#     
#     plot(performance(prediction(c(as.numeric(unlist(dfA[1]))), factor(c(as.numeric(unlist(dfA[2]))), levels=c(0,1))), 'tpr', 'fpr'), main= paste('AUC', performance(prediction(c(as.numeric(unlist(dfA[1]))), factor(c(as.numeric(unlist(dfA[2]))), levels=c(0,1))), 'auc')@y.values[[1]]) )
#     # print(performance(prediction(c(as.numeric(unlist(dfA[1]))), factor(c(as.numeric(unlist(dfA[2]))), levels=c(0,1))), 'auc')@y.values[[1]])
# 
# }
# 
# plot_rocs('Basal', 'combination', 1, 'None')
```


## Feature importance

```{r}
response_types <- c(c('Basal','Luminal A', 'Luminal B', 'HER2', 'Normal-like'),c("ERplusHER2-", "ER-HER2-", "ERplusHER2plus", "ER-HER2plus"))
prediction_types <- c('combination', 'shape_and_scale', 'shape', 'scale', 'TME_proportion', 'tumour_proportion', 'originalTME_proportion', 'originalTumour_proportion')

toModel <- apply_filtering(init_predictors, 100)
toModel <- split(toModel, by = 'isTestCohort')
sds <- apply(toModel$train, 2, sd)
stdDF <- tibble(var = colnames(toModel$train), std = sds)

coefList_all <- data.frame(matrix(nrow = 0, ncol = 4))
for (t in response_types){
  file <- paste('coefList_', t,sep='')
  for (p in prediction_types){
      path <- paste(file, '_', p, sep ='')
      files <- grep(path,list.files(path = here('scratch/coeflists_run2/')),fixed=T,value=T)
      for (f in files){
      coefList <- readRDS(paste(here('scratch/coeflists_run2/'),f,sep=''))
      coefList <- coefList %>% mutate(var = gsub('_CPh', '',var, fixed=T))
      coefList <- merge(coefList, stdDF, by='var', all.x=T)
      coefList <- coefList %>% mutate(std_val = val * std) %>% dplyr::select(-c('val', 'std'))
      coefList_all <- rbind(coefList_all, coefList)
      }
  }
}

coefList_all <- na.omit(coefList_all)
coefList_all <- coefList_all %>% group_by(response, predictor, var) %>% summarise(mean_coef = mean(std_val))
coefList_all <- coefList_all %>% mutate(dir = ifelse(mean_coef < 0, 'neg', 'pos'))
```
```{r}
response_types <- c(c('Basal','Luminal A', 'Luminal B', 'HER2', 'Normal-like'),c("ER+HER2-", "ER-HER2-", "ER+HER2+", "ER-HER2+"))

for (r in response_types){
  plot_list <- list()
  for (t in c('tumour_proportion','TME_proportion')){
    p <- ggplot(data = coefList_all %>% filter(response == r) %>% filter(predictor == t)) + 
      geom_col(aes(x=var, y=abs(mean_coef),fill=dir)) + theme_bw() + 
      coord_flip() + xlab('') + ylab('Relative importance') + 
      scale_fill_manual(values=c('red','green')) +
      theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) +
      ggtitle(t)
      
    plot_list[[length(plot_list) + 1]] <- p
  }
  
  for (t in c('shape', 'scale', 'shape_and_scale', 'combination')){
    p<- ggplot(data = coefList_all  %>% filter(response == r) %>% filter(predictor == t)  %>% arrange(desc(abs(mean_coef))) %>% slice(1:25)) + 
    geom_col(aes(x=reorder(var,abs(mean_coef)), y=abs(mean_coef),fill=dir)) + theme_bw() +
    coord_flip() + xlab('') + ylab('Relative importance') +
    scale_fill_manual(values=c('red','green')) + 
    theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) +
      ggtitle(t)
    
    plot_list[[length(plot_list) + 1]] <- p
  }
  
  plot_grid(plotlist = plot_list, ncol = 3)
  
  ggsave(paste(here('output/Method_comparison/feature_importance/feature_importance_'), gsub('+', 'plus', r, fixed=T), '.pdf',sep = ''),width=15,height=15)

}
```



```{r}
coefList_all <- coefList_all %>% mutate(var = gsub('_CPh', '', var, fixed=T))
coefList_all_withoutCombi <- coefList_all %>% filter(predictor != 'combination') %>% filter(predictor != 'shape_and_scale') %>% filter(mean_coef  > 0.1 | mean_coef < -0.1)
coefList_all_withCombi <- coefList_all %>% filter(predictor == 'combination')  %>% filter(mean_coef  > 0.1 | mean_coef < -0.1)

saveRDS(coefList_all, here('scratch/multivariateFeatureImportance.rds'))

ylabels <- function(coefList){
  all <- c(cPh_tumour, cPh_tme, cPh_tumour_original, cPh_tme_original,sort(unlist(grep('shape', colnames(apply_filtering(init_predictors, 100)), value=T))),sort(unlist(grep('scale', colnames(apply_filtering(init_predictors, 100)), value=T))))
  selection <- intersect(all, coefList$var)
  
  return(selection)
}

plot_coefficients <- function(coefList){
  ggplot(coefList, aes(response,var))  + 
  geom_tile(aes(fill = mean_coef))  + 
  geom_text(aes(label = (round(as.numeric(mean_coef),2))),size=3)  +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
  panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.text.x = element_text(size = 10)) +
  # theme(axis.text.y = element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  # scale_fill_manual(values= c('grey','red', 'green'), na.value = 'grey') +
  scale_fill_gradientn(colours=c("red",'white', "green"),limits = c(min(coefList$mean_coef),max(coefList$mean_coef)),values = c(0,abs(min(coefList$mean_coef))/(abs(min(coefList$mean_coef))+abs(max(coefList$mean_coef))) ,1),name='coefficient') +
  ylim(ylabels(coefList)) + xlim(response_types) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
  
}

p <- plot_coefficients(coefList_all_withoutCombi)
ggsave(here('output/Method_comparison/feature_importance/overview_run2.pdf'),height=15, width=10)

p <- plot_coefficients(coefList_all_withCombi)
ggsave(here('output/Method_comparison/feature_importance/overview_combination_run2.pdf'),height=10, width=12)



coefList_all_withCombi <- coefList_all %>% filter(predictor == 'shape_and_scale')
ggsave(here('output/Method_comparison/feature_importance/overview_shapeAndScale_run2.pdf'),height=20)
```

Do the considered features contain common cell types. 

```{r}
subset <- coefList_all_withoutCombi  %>% filter(predictor == 'shape' |predictor == 'scale')  %>% ungroup(predictor) %>% select(-c(predictor))
subset <- subset %>% separate(var, c('phenotype_from', 'phenotype_to'), sep = '_to_')  %>% mutate(phenotype_from = gsub('scale_', '', phenotype_from, fixed=T)) %>% mutate(phenotype_from = gsub('shape_', '', phenotype_from, fixed=T))
phenotype_from <- subset %>% group_by(response, phenotype_from) %>% summarise(n = n()) %>% mutate(type = 'phenotype_from')
phenotype_to <- subset  %>% group_by(response, phenotype_to)  %>% count(phenotype_to) %>% mutate(type = 'phenotype_to')
coef_count <- rbind(phenotype_from, phenotype_to)

ggplot(coef_count %>% filter(type == 'phenotype_from'), aes(response, phenotype_from)) + geom_tile(aes(fill = n))  + geom_text(aes(label = n),size=5,color='white') + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.text.x = element_text(size = 10))  + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))  + xlim(response_types) + ylim(c(c(unlist(gsub('_CPh', '', cPh_tumour, fixed=T)), unlist(gsub('_CPh', '', cPh_tme, fixed=T)))))

ggsave(here('output//Method_comparison/feature_importance/overview_run2_FROMcounts.pdf'),height=7,width=10)

ggplot(coef_count %>% filter(type == 'phenotype_to'), aes(response, phenotype_to)) + geom_tile(aes(fill = n))  + geom_text(aes(label = n),size=5,color='white') + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.text.x = element_text(size = 10))  + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))  + xlim(response_types) + ylim(c(c(unlist(gsub('_CPh', '', cPh_tumour, fixed=T)), unlist(gsub('_CPh', '', cPh_tme, fixed=T)))))

ggsave(here('output//Method_comparison/feature_importance/overview_run2_TOcounts.pdf'),height=7,width=10)


```

## Univariate evaluation
Analyse the individual effect of features.

```{r}
original_density_features <- getCellProportionsPerImage() %>% filter(isTumour == T) %>% dplyr::select(-c(isTumour))
colnames(original_density_features) <- gsub('_CPh', '_originalClass', colnames(original_density_features), fixed = T)

density_features <- getCellProportionsPerImageAlternative()%>% filter(isTumour == T) %>% dplyr::select(-c(isTumour))
shape_features <- getShapeFeaturesAlternative() %>% filter(tnumber %in% density_features$ImageNumber)
scale_features <- getScaleFeaturesAlternative() %>% filter(tnumber %in% density_features$ImageNumber)
  
generate_matrix_zeroOneScaling <- function(df, col_rownames ,subselection=NULL, NA_percentage=0, scale_rows=FALSE){
  m <- as.data.frame(df)
  rownames(m) <- m[,col_rownames]
  m <- subset(m,select = -c(get(col_rownames)))
  
  # Filtering
  m <- m[, which(colMeans(!is.na(m)) > NA_percentage)]

  m <- replace(m,is.na(m),0)
  m <- as.data.frame(m)
  
  
  # Scaling
  m <- apply(m, 2, function(x) (x - min(x)) / (max(x) - min(x)))
  
  
  return(m)
}

shape_features <- generate_matrix_zeroOneScaling(shape_features,'tnumber')
scale_features <- generate_matrix_zeroOneScaling(scale_features,'tnumber')
density_features <- generate_matrix_zeroOneScaling(density_features, 'ImageNumber')
original_density_features <- generate_matrix_zeroOneScaling(original_density_features, 'ImageNumber')
```

```{r}
# Load required libraries
library(multcomp)
library(ggrepel)

computePvalues <- function(featureSet, r){
  print(r)
  subset <- merge(featureSet, clinical_data %>% dplyr::select(c(ImageNumber, ER_HER2_status, PAM50)), by.x='row.names', by.y='ImageNumber') %>% dplyr::select(-dplyr::any_of(c('Row.names', 'ImageNumber')))
  subset <- subset %>% mutate(group = ifelse(PAM50 == r | ER_HER2_status == r, r, paste('no', r)))

  subset <- subset %>% dplyr::select(-c(ER_HER2_status, PAM50))
  response <- subset$group

  # Create an empty vector to store the adjusted p-values and log2 fold changes
  p_values <- rep(NA, ncol(subset)-1)
  log2_fold_changes <- rep(NA, ncol(subset)-1)

  # Perform univariate feature importance analysis for each feature
  for (i in 1:(ncol(subset)-1)) {
    # Extract the current feature
    feature <- subset[, i]

    # Perform a t-test to assess the significance of the feature
    test_result <- t.test(feature ~ response)

    # Extract the p-value from the test result
    p_value <- test_result$p.value

    # Calculate the log2 fold change between the response groups
    mean_response <- tapply(feature, response, mean)
    log2_fold_change <- log2((mean_response[r]+0.001) / mean_response[paste('no', r)])

    # Store the p-value and log2 fold change in their respective vectors
    p_values[i] <- p_value
    log2_fold_changes[i] <- log2_fold_change
  }

  # Apply p-value adjustment method (e.g., Bonferroni, Benjamini-Hochberg)
  adjusted_p_values <- p.adjust(p_values, method = "bonferroni")

  # Create a data frame with the features, p-values, log2 fold changes, and adjusted p-values
  result <- data.frame(Feature = colnames(subset %>% dplyr::select(-c(group))),
                       p_value = p_values,
                       log2FoldChange = log2_fold_changes,
                       Adjusted_p_value = adjusted_p_values) %>%
            mutate(Sig = ifelse(Adjusted_p_value < 0.05, T, F))

  return(result)
}



univariateFeatureImportance <- data.frame(matrix(nrow=0, ncol=7))
for (s in setdiff(unique(clinical_data$PAM50),NA)){
  univariateFeatureImportance <- rbind(univariateFeatureImportance, computePvalues(original_density_features, s) %>% mutate(response = s) %>% mutate(featureSet = 'original_densities'))
  univariateFeatureImportance <- rbind(univariateFeatureImportance, computePvalues(density_features, s) %>% mutate(response = s) %>% mutate(featureSet = 'densities'))
  univariateFeatureImportance <- rbind(univariateFeatureImportance, computePvalues(shape_features, s) %>% mutate(response = s) %>% mutate(featureSet = 'shape'))
  univariateFeatureImportance <- rbind(univariateFeatureImportance, computePvalues(scale_features, s) %>% mutate(response = s) %>% mutate(featureSet = 'scale'))

}

for (s in setdiff(unique(clinical_data$ER_HER2_status),NA)){
  univariateFeatureImportance <- rbind(univariateFeatureImportance, computePvalues(original_density_features, s) %>% mutate(response = s) %>% mutate(featureSet = 'original_densities'))
  univariateFeatureImportance <- rbind(univariateFeatureImportance, computePvalues(density_features, s) %>% mutate(response = s) %>% mutate(featureSet = 'densities'))
  univariateFeatureImportance <- rbind(univariateFeatureImportance, computePvalues(shape_features, s) %>% mutate(response = s) %>% mutate(featureSet = 'shape'))
  univariateFeatureImportance <- rbind(univariateFeatureImportance, computePvalues(scale_features, s) %>% mutate(response = s) %>% mutate(featureSet = 'scale'))

}

univariateFeatureImportance <- univariateFeatureImportance %>% mutate(minlogP = -log(Adjusted_p_value, base = 10))

saveRDS(univariateFeatureImportance, here('scratch/univariateFeatureImportance.rds'))
```


## Volcano plots

```{r}
# Creating the volcano plot
fold_threshold = 1
p_value = -log10(0.05)
univariateFeatureImportance <- univariateFeatureImportance %>% mutate(Sig = ifelse((minlogP > -log10(0.05)) & (log2FoldChange < -fold_threshold | log2FoldChange > fold_threshold), T, F))

print(univariateFeatureImportance %>% filter(Sig == T) %>% filter(featureSet == 'densities'))


ggplot() +
  geom_point(data = (univariateFeatureImportance %>% filter(Sig == T)), aes(x = log2FoldChange, y =minlogP, colour=response)) +
  geom_point(data = (univariateFeatureImportance %>% filter(Sig == F)), aes(x = log2FoldChange, y =minlogP),color='grey') +
  labs(x = "Log2 Fold Change",
       y = "-log10 Adjusted P-value",
       title = "Univariate feature importance") + geom_vline(xintercept=c(-fold_threshold, fold_threshold), col="black") +
        geom_hline(yintercept=-log10(0.05), col="black") +theme_bw()

ggsave(here('output/Method_comparison/feature_importance/univariate_volcanoplot.pdf'))

```
## Merge feature selection

```{r}
coefList_all <- readRDS(here('scratch/multivariateFeatureImportance.rds'))
univariateFeatureImportance <- readRDS(here('scratch/univariateFeatureImportance.rds')) %>% mutate(Feature = (ifelse(featureSet == 'shape' | featureSet == 'scale',paste(featureSet,Feature, sep='_'),Feature)))

individualmodels <- coefList_all %>% filter(predictor == 'TME_proportion' | predictor == 'tumour_proportion' | predictor == 'scale' | predictor == 'shape' | predictor == 'shape_and_scale') %>% filter(mean_coef < -0.1 | mean_coef > 0.1) %>% mutate(binary = 1) %>%ungroup(predictor) %>% distinct(response,var)  %>% mutate(binary = 1)

combinedmodel <- coefList_all %>% filter(predictor == 'combination') %>% filter(mean_coef < -0.1 | mean_coef > 0.1)  %>% mutate(binary = 1)  %>%ungroup(predictor) %>% distinct(response,var)  %>% mutate(binary = 1)

UnivariateModel <- univariateFeatureImportance %>% filter(Sig == T) %>% mutate(Feature = gsub('_CPh','', Feature, fixed=T)) %>% distinct(response,Feature)  %>% mutate(binary = 1)

individualmodelsMatrix <- reshape2::dcast(individualmodels, response ~ var,value.var = 'binary' )
individualmodelsMatrix[is.na(individualmodelsMatrix)] <- 0
rownames(individualmodelsMatrix) <- individualmodelsMatrix$response
individualmodelsMatrix <- individualmodelsMatrix %>% dplyr::select(-c(response))

univariatemodelMatrix <- reshape2::dcast(UnivariateModel,response ~ Feature, value.var='binary')
univariatemodelMatrix[is.na(univariatemodelMatrix)] <- 0
rownames(univariatemodelMatrix) <- univariatemodelMatrix$response
univariatemodelMatrix <- univariatemodelMatrix %>% dplyr::select(-c(response))

combinedmodelMatrix <- reshape2::dcast(combinedmodel, response ~ var, value.var ='binary')
combinedmodelMatrix[is.na(combinedmodelMatrix)] <- 0
rownames(combinedmodelMatrix) <- combinedmodelMatrix$response
combinedmodelMatrix['Normal-like',] <- 0
combinedmodelMatrix['ER-HER2-',] <- 0
combinedmodelMatrix <- combinedmodelMatrix %>% dplyr::select(-c(response))



```


```{r}
matrix_operation <- function(matrix1, matrix2, operator) {
  rownames1 <- rownames(matrix1)
  colnames1 <- colnames(matrix1)
  rownames2 <- rownames(matrix2)
  colnames2 <- colnames(matrix2)
  
  all_rownames <- unique(c(rownames1, rownames2))
  all_colnames <- unique(c(colnames1, colnames2))
  
  missing_rownames1 <- setdiff(all_rownames, rownames1)
  missing_rownames2 <- setdiff(all_rownames, rownames2)
  
  for (rowname in missing_rownames1) {
    matrix1 <- rbind(matrix1, matrix(0, ncol(matrix1), 1))
    rownames(matrix1)[nrow(matrix1)] <- rowname
  }
  
  for (rowname in missing_rownames2) {
    matrix2 <- rbind(matrix2, matrix(0, ncol(matrix2), 1))
    rownames(matrix2)[nrow(matrix2)] <- rowname
  }
  
  missing_colnames1 <- setdiff(all_colnames, colnames1)
  missing_colnames2 <- setdiff(all_colnames, colnames2)
  
  for (colname in missing_colnames1) {
    matrix1 <- cbind(matrix1, matrix(0, nrow(matrix1), 1))
    colnames(matrix1)[ncol(matrix1)] <- colname
  }
  
  for (colname in missing_colnames2) {
    matrix2 <- cbind(matrix2, matrix(0, nrow(matrix2), 1))
    colnames(matrix2)[ncol(matrix2)] <- colname
  }
  
  matrix1 <- matrix1[match(all_rownames, rownames(matrix1)), match(all_colnames, colnames(matrix1))]
  matrix2 <- matrix2[match(all_rownames, rownames(matrix2)), match(all_colnames, colnames(matrix2))]
  
  if (operator == '+'){
      result <- matrix1 + matrix2
  }
  
  if (operator == '*'){
      result <- matrix1 * matrix2
  }
  
  rownames(result) <- all_rownames
  colnames(result) <- all_colnames
  
  return(result)
}


result <- matrix_operation(matrix_operation(individualmodelsMatrix, combinedmodelMatrix, '+'), univariatemodelMatrix, '+')
result <- result[c('ER-HER2+','ER+HER2+','ER-HER2-','ER+HER2-','Normal-like','Basal','HER2', 'Luminal B', 'Luminal A' ),]

```

```{r}
library(tidyHeatmap)
# result <- result[c(response_types),,drop=FALSE]

library(circlize)
library(viridis)
col_fun = colorRamp2(c(0, 1,2, 3), c('white', "#FFFF00","#FF8000","#FF0000"))

hm <- Heatmap(t(as.matrix(result)), cluster_columns = F,cluster_rows=T, column_names_gp = gpar(fontsize=8), row_names_gp = gpar(fontsize=3),col = col_fun)
save_pdf(hm, here('output/Method_comparison/feature_importance/mergedFeatureSelection.pdf'),width=6,height=12)
```
```{r}
saveRDS(result, file = here('scratch/significantFeatures.rds'))
```



## Example plots
Show plots of important features.

```{r}
densities <- getCellProportionsPerImageAlternative() %>% filter(isTumour == T)
shape_features <- getShapeFeaturesAlternative() %>% filter(tnumber %in% (densities %>% pull('ImageNumber')))
scale_features <- getScaleFeaturesAlternative() %>% filter(tnumber %in% (densities %>% pull('ImageNumber')))
```

```{r}
library(ggpubr)
library(rstatix)
library(rlang)

names(density_features) <- gsub('+', 'plus', names(density_features), fixed = T)
names(density_features) <- gsub('-', 'min', names(density_features), fixed = T)

names(densities) <- gsub('+', 'plus', names(densities), fixed = T)
names(densities) <- gsub('-', 'min', names(densities), fixed = T)


ShowPlot <- function(df, response, feature){
  d <- merge(df,clinical_data,by.x='ImageNumber', by.y='ImageNumber')
  
  print(head(d))
  
  d <- d %>% mutate(group = ifelse(PAM50 == response | ER_HER2_status == response, response, paste('no', response) ))
  
  p <- ggboxplot(na.omit(d), x = 'group', y = feature) + ylim(0,1) + ylab(gsub('plus', '+', gsub('min', '-', feature, fixed = T), fixed = T))
  return(p)
}

ShowPlot(densities, "Basal", "CKplus_ERorHER2plus_cells_CPh")
```



```{r}
library(patchwork)

allParametersAlternative <- getALLParametersAlternative()
pam_types <- c("Basal","Luminal A","Luminal B","HER2","Normal-like")
mol_types <- c("ER+HER2-","ER-HER2-","ER+HER2+","ER-HER2+")

retrieveParameters <- function(df, response,feature){
  d <- merge(df %>% filter(phenotype_combo == feature),clinical_data  %>% select(c(ImageNumber, PAM50, ER_HER2_status)),by.x='tnumber', by.y='ImageNumber')

  d <- d %>% mutate(group = ifelse(PAM50 == response | ER_HER2_status == response, response, paste('no', response) ))
  
  mean_d <- d %>% group_by(group) %>% summarise(mean_shape = mean(shape), mean_scale =mean(scale))
  shape_group <- (mean_d %>% filter(group == response) %>% pull(mean_shape))[[1]]
  scale_group <-  (mean_d %>% filter(group == response) %>% pull(mean_scale))[[1]]
  shape_nogroup <- (mean_d %>% filter(group == paste('no', response)) %>% pull(mean_shape))[[1]]
  scale_nogroup <- (mean_d %>% filter(group == paste('no', response)) %>% pull(mean_scale))[[1]]
  
  return(list('shape' = shape_group, 'scale' = scale_group, 'shape_alternative' = shape_nogroup, 'scale_alternative' = scale_nogroup))
}


create_boxplot <- function(df, response,feature){
  d <- merge(df %>% filter(phenotype_combo == feature),clinical_data  %>% select(c(ImageNumber, PAM50, ER_HER2_status)),by.x='tnumber', by.y='ImageNumber')
  d <- d %>% mutate(group = ifelse(PAM50 == response | ER_HER2_status == response, response, paste('no', response) ))
   
  b1 <- ggplot(na.omit(d)) + geom_boxplot(aes(x=group, y=shape)) + theme_bw() + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + xlim(response, paste('no', response))
  b2 <- ggplot(na.omit(d)) + geom_boxplot(aes(x=group, y=scale)) + theme_bw() + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))  + xlim(response, paste('no', response))
  
  return(plot_grid(b1,b2,nrow=1))
  
}

showDistanceCurvesPAM <- function(df, response,other_types, feature){
  g1 <- ggplot() + 
    stat_function(fun = dweibull, args = list(shape = retrieveParameters(df,response,feature)$shape,scale = retrieveParameters(df,response,feature)$scale), aes(colour=response))  +
    stat_function(fun = dweibull, args = list(shape = retrieveParameters(df,other_types[[1]],feature)$shape,scale = retrieveParameters(df,other_types[[1]],feature)$scale), aes(colour=other_types[[1]]))  +
    stat_function(fun = dweibull, args = list(shape = retrieveParameters(df,other_types[[2]],feature)$shape,scale = retrieveParameters(df,other_types[[2]],feature)$scale), aes(colour=other_types[[2]]))  +
    stat_function(fun = dweibull, args = list(shape = retrieveParameters(df,other_types[[3]],feature)$shape,scale = retrieveParameters(df,other_types[[3]],feature)$scale), aes(colour=other_types[[3]]))  +
    stat_function(fun = dweibull, args = list(shape = retrieveParameters(df,other_types[[4]],feature)$shape,scale = retrieveParameters(df,other_types[[4]],feature)$scale), aes(colour=other_types[[4]]))  +
  xlim(0,600) + theme_bw() + xlab('micron') + ylab('N') + ylim(0,0.035) + ggtitle(feature)
    
  b1 <- create_boxplot(df, response,feature)
  g_total <- g1 + inset_element(b1, 0.4, 0.2, 0.98, 0.98)
  return(g_total)

  
}

showDistanceCurvesMS <- function(df, response,other_types, feature){
  g1 <- ggplot() + 
    stat_function(fun = dweibull, args = list(shape = retrieveParameters(df,response,feature)$shape,scale = retrieveParameters(df,response,feature)$scale), aes(colour=response))  +
    stat_function(fun = dweibull, args = list(shape = retrieveParameters(df,other_types[[1]],feature)$shape,scale = retrieveParameters(df,other_types[[1]],feature)$scale), aes(colour=other_types[[1]]))  +
    stat_function(fun = dweibull, args = list(shape = retrieveParameters(df,other_types[[2]],feature)$shape,scale = retrieveParameters(df,other_types[[2]],feature)$scale), aes(colour=other_types[[2]]))  +
    stat_function(fun = dweibull, args = list(shape = retrieveParameters(df,other_types[[3]],feature)$shape,scale = retrieveParameters(df,other_types[[3]],feature)$scale), aes(colour=other_types[[3]]))  +
  xlim(0,600) + theme_bw() + xlab('micron') + ylab('N') + ylim(0,0.035) + ggtitle(feature)
    
  b1 <- create_boxplot(df, response,feature)
  g_total <- g1 + inset_element(b1, 0.4, 0.2, 0.98, 0.98)
  return(g_total)

  
  }
  
# Show examples for every subtype
showDistanceCurvesPAM(allParametersAlternative, 'Basal',setdiff(pam_types,'Basal'),'Endothelial_to_CK+_ERorHER2-_cells')

showDistanceCurvesPAM(allParametersAlternative, 'Luminal A',setdiff(pam_types,'Luminal A'),'Ki67+_cells_to_CKmed_ERorHER2-_cells')

showDistanceCurvesPAM(allParametersAlternative, 'Luminal B',setdiff(pam_types,'Luminal B'),'Ki67+_cells_to_CK+_ERorHER2+_cells')

showDistanceCurvesPAM(allParametersAlternative, 'HER2',setdiff(pam_types,'HER2'),'CK-_cells_to_CK+_ERorHER2+_cells')

showDistanceCurvesPAM(allParametersAlternative, 'Normal-like',setdiff(pam_types,'Normal-like'),'CD38+_cells_to_Myofibroblasts')

showDistanceCurvesMS(allParametersAlternative, 'ER+HER2-', setdiff(mol_types, 'ER+HER2-'),'CK-MHC+_cells_to_Granulocytes_Macrophages')

showDistanceCurvesMS(allParametersAlternative, 'ER-HER2-', setdiff(mol_types, 'ER-HER2-'),'Fibroblasts_to_CK+_ERorHER2+_cells')

showDistanceCurvesMS(allParametersAlternative, 'ER+HER2+', setdiff(mol_types, 'ER+HER2+'),'CD8+_cells_to_B cells')

showDistanceCurvesMS(allParametersAlternative, 'ER-HER2+', setdiff(mol_types, 'ER-HER2+'),'Endothelial_to_Endothelial')

```



